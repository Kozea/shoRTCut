// Generated by CoffeeScript 1.6.3
(function() {
  var BinaryChannel, Channel, Loggable, Peer, ShoRTCut, TextChannel, WebSocket, debug, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  debug = true;

  Loggable = (function() {
    function Loggable() {}

    Loggable.prototype.log = function() {
      var log_args, name;
      if (debug) {
        name = this.constructor.name;
        log_args = [name].concat(Array.prototype.slice.call(arguments, 0));
        return console.log.apply(console, log_args);
      }
    };

    Loggable.prototype.error = function() {
      if (typeof console !== "undefined" && console !== null ? console.error : void 0) {
        console.error.apply(console, arguments);
      } else {
        alert(arguments[0]);
      }
      return window.last_err_args = arguments;
    };

    return Loggable;

  })();

  Channel = (function(_super) {
    __extends(Channel, _super);

    function Channel(ch, rtc) {
      this.ch = ch;
      this.rtc = rtc;
      this.log("Creating channel");
      this.ch.onopen = this.open.bind(this);
      this.ch.onmessage = this.message.bind(this);
      this.ch.onerror = this.fail.bind(this);
      this.ch.onclose = this.close.bind(this);
    }

    Channel.prototype.open = function() {
      var log_args;
      log_args = ['open'].concat(Array.prototype.slice.call(arguments, 0));
      return this.log.apply(this, log_args);
    };

    Channel.prototype.close = function() {
      var log_args;
      log_args = ['close'].concat(Array.prototype.slice.call(arguments, 0));
      return this.log.apply(this, log_args);
    };

    Channel.prototype.fail = function() {
      var log_args;
      log_args = ['error'].concat(Array.prototype.slice.call(arguments, 0));
      return this.error.apply(this, log_args);
    };

    Channel.prototype.send = function(cmd, data) {
      var message, type;
      type = cmd.constructor.name;
      if (type === 'String') {
        if (data) {
          message = "" + cmd + "|" + data;
        } else {
          message = cmd;
        }
        this.log('Sending', message);
        return this.ch.send(message);
      } else {
        return this.ch.send(cmd);
      }
    };

    Channel.prototype.message = function(e) {
      var cmd, data, message, pipe;
      if (!e.data) {
        this.log('Empty message');
        return;
      }
      message = e.data;
      this.log('Receiving', message);
      pipe = message.indexOf('|');
      if (pipe > -1) {
        cmd = message.substr(0, pipe);
        data = message.substr(pipe + 1);
      } else {
        cmd = message;
        data = '';
      }
      if (!(cmd in this)) {
        return this.error("Unknown command " + cmd, message);
      } else {
        return this[cmd](data);
      }
    };

    Channel.prototype.quit = function() {
      return this.ch.close();
    };

    return Channel;

  })(Loggable);

  TextChannel = (function(_super) {
    __extends(TextChannel, _super);

    function TextChannel() {
      _ref = TextChannel.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return TextChannel;

  })(Channel);

  BinaryChannel = (function(_super) {
    __extends(BinaryChannel, _super);

    function BinaryChannel(ch, rtc) {
      this.ch = ch;
      this.rtc = rtc;
      this.ch.binaryType = 'arraybuffer';
      BinaryChannel.__super__.constructor.call(this, this.ch, this.rtc);
      this.sendBuffer = [];
    }

    BinaryChannel.prototype.message = function(e) {
      if (e.data === "\x02") {
        return this.log('Start of text ?!');
      } else {
        return this.binary(e.data);
      }
    };

    BinaryChannel.prototype.send = function(ab) {
      var _ab;
      if (ab) {
        this.sendBuffer.push(ab);
      }
      try {
        _ab = this.sendBuffer.shift();
        return this.ch.send(_ab);
      } catch (_error) {
        this.sendBuffer.unshift(_ab);
        return setTimeout(this.send.bind(this), 100);
      }
    };

    return BinaryChannel;

  })(Channel);

  WebSocket = (function(_super) {
    __extends(WebSocket, _super);

    function WebSocket() {
      _ref1 = WebSocket.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    WebSocket.prototype.ECHO = function(message) {
      return this.log(message);
    };

    WebSocket.prototype.INIT = function() {
      return this.rtc.user_media();
    };

    WebSocket.prototype.START = function() {
      this.log('Creating offer');
      this.rtc.peer.offering();
      return this.rtc.caller();
    };

    WebSocket.prototype.CALL = function(message) {
      this.rtc.peer.remote_description(new RTCSessionDescription(JSON.parse(message)));
      this.rtc.peer.answering();
      return this.rtc.callee();
    };

    WebSocket.prototype.ANSWER = function(message) {
      return this.rtc.peer.remote_description(new RTCSessionDescription(JSON.parse(message)));
    };

    WebSocket.prototype.ICE = function(message) {
      return this.rtc.ice_in(new RTCIceCandidate(JSON.parse(message)));
    };

    WebSocket.prototype.RESET = function() {
      return this.rtc.reset();
    };

    WebSocket.prototype.WAIT = function() {};

    WebSocket.prototype.FULL = function() {
      return alert("There's already 2 persons for this uuid");
    };

    return WebSocket;

  })(Channel);

  Peer = (function(_super) {
    __extends(Peer, _super);

    function Peer(pc, rtc) {
      this.pc = pc;
      this.rtc = rtc;
      this.pc.onicecandidate = this.ice_out.bind(this);
      this.pc.onaddstream = this.remote_stream.bind(this);
      this.pc.ondatachannel = this.data_channel.bind(this);
      this.pc.addStream(this.rtc.local_stream);
    }

    Peer.prototype.ice_in = function(ice) {
      return this.pc.addIceCandidate(ice);
    };

    Peer.prototype.ice_out = function(event) {
      this.log('Got ice', event.candidate);
      if (event.candidate) {
        return this.rtc.ice_out(JSON.stringify(new RTCIceCandidate(event.candidate)));
      }
    };

    Peer.prototype.offering = function() {
      this.log('Offering');
      this.make_channel();
      return this.pc.createOffer(this.caller_local_description.bind(this), this.error.bind(this), {
        mandatory: {
          OfferToReceiveAudio: true,
          OfferToReceiveVideo: true
        }
      });
    };

    Peer.prototype.answering = function() {
      this.log('Answering');
      return this.pc.createAnswer(this.callee_local_description.bind(this), this.error.bind(this), {
        mandatory: {
          OfferToReceiveAudio: true,
          OfferToReceiveVideo: true
        }
      });
    };

    Peer.prototype.caller_local_description = function(desc) {
      this.local_description(desc);
      return this.rtc.calling(JSON.stringify(desc));
    };

    Peer.prototype.callee_local_description = function(desc) {
      this.local_description(desc);
      return this.rtc.answering(JSON.stringify(desc));
    };

    Peer.prototype.local_description = function(desc) {
      this.log('Got local description', desc);
      return this.pc.setLocalDescription(desc);
    };

    Peer.prototype.remote_description = function(desc) {
      this.log('Got remote description', desc);
      return this.pc.setRemoteDescription(desc);
    };

    Peer.prototype.remote_stream = function(event) {
      this.log('Got remote stream', event.stream);
      return this.rtc.assign_remote_stream_url(URL.createObjectURL(event.stream));
    };

    Peer.prototype.data_channel = function(event) {
      this.log('Got remote channel', event.channel);
      if (event.channel.label === 'text') {
        this.text_channel = new this.rtc.TextChannel(event.channel, this.rtc);
      }
      if (event.channel.label === 'binary') {
        return this.binary_channel = new this.rtc.BinaryChannel(event.channel, this.rtc);
      }
    };

    Peer.prototype.make_channel = function() {
      this.log('Got local channel');
      this.text_channel = new this.rtc.TextChannel(this.pc.createDataChannel('text', {}), this.rtc);
      return this.binary_channel = new this.rtc.BinaryChannel(this.pc.createDataChannel('binary', {}), this.rtc);
    };

    Peer.prototype.quit = function() {
      var _ref2, _ref3;
      if ((_ref2 = this.text_channel) != null) {
        _ref2.quit();
      }
      if ((_ref3 = this.binary_channel) != null) {
        _ref3.quit();
      }
      return this.pc.close();
    };

    return Peer;

  })(Loggable);

  ShoRTCut = (function(_super) {
    __extends(ShoRTCut, _super);

    ShoRTCut.prototype.Loggable = Loggable;

    ShoRTCut.prototype.Channel = Channel;

    ShoRTCut.prototype.Peer = Peer;

    ShoRTCut.prototype.TextChannel = Channel;

    ShoRTCut.prototype.BinaryChannel = BinaryChannel;

    ShoRTCut.prototype.WebSocket = WebSocket;

    function ShoRTCut(options) {
      this.options = options;
      debug = this.options.debug;
      this.Peer = Peer;
      this.WebSocket = WebSocket;
      this.TextChannel = TextChannel;
      this.FileChannel = BinaryChannel;
    }

    ShoRTCut.prototype.start = function() {
      return this.ws = new this.WebSocket(new window.WebSocket("wss://" + this.options.host + "/ws" + this.options.path), this);
    };

    ShoRTCut.prototype.user_media = function() {
      this.log('Getting user media');
      return window.getUserMedia({
        audio: true,
        video: true
      }, this.init.bind(this), this.error.bind(this));
    };

    ShoRTCut.prototype.init = function(stream) {
      this.log('Assigning local stream', stream);
      this.assign_local_stream_url(URL.createObjectURL(stream));
      this.local_stream = stream;
      this.log('Connecting');
      this.connect();
      return this.ws.send('READY');
    };

    ShoRTCut.prototype.calling = function(desc) {
      return this.ws.send('CALL', desc);
    };

    ShoRTCut.prototype.answering = function(desc) {
      return this.ws.send('ANSWER', desc);
    };

    ShoRTCut.prototype.connect = function() {
      return this.peer = new this.Peer(new RTCPeerConnection({
        iceServers: [createIceServer('stun:stun.l.google.com:19302'), createIceServer('turn:' + this.options.turn_server, this.options.turn_username, this.options.turn_password)],
        optional: [
          {
            DtlsSrtpKeyAgreement: true
          }
        ]
      }), this);
    };

    ShoRTCut.prototype.ice_out = function(ice) {
      return this.ws.send('ICE', ice);
    };

    ShoRTCut.prototype.ice_in = function(ice) {
      return this.peer.ice_in(ice);
    };

    ShoRTCut.prototype.reset = function() {
      this.peer.quit();
      return this.connect();
    };

    ShoRTCut.prototype.assign_local_stream_url = function(url) {
      return this.error('You must override this method to set local stream url');
    };

    ShoRTCut.prototype.assign_remote_stream_url = function(url) {
      return this.error('You must override this method to set remote stream url');
    };

    ShoRTCut.prototype.caller = function() {};

    ShoRTCut.prototype.callee = function() {};

    return ShoRTCut;

  })(Loggable);

  this.ShoRTCut = ShoRTCut;

}).call(this);
