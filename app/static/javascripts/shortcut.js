// Generated by CoffeeScript 1.6.3
(function() {
  var Channel, Loggable, Peer, ShoRTCut, WebSocket, debug, options, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  options = window.options;

  debug = options != null ? options.debug : void 0;

  Loggable = (function() {
    function Loggable() {}

    Loggable.prototype.log = function() {
      var log_args, name;
      if (debug) {
        name = (this.ch != null ? this.ch : this).constructor.name;
        log_args = [name].concat(Array.prototype.slice.call(arguments, 0));
        return console.log.apply(console, log_args);
      }
    };

    Loggable.prototype.error = function() {
      if (typeof console !== "undefined" && console !== null ? console.error : void 0) {
        return console.error.apply(console, arguments);
      } else {
        return alert(arguments[0]);
      }
    };

    return Loggable;

  })();

  Channel = (function(_super) {
    __extends(Channel, _super);

    function Channel(ch, rtc) {
      this.ch = ch;
      this.rtc = rtc;
      this.log("Creating channel");
      this.ch.onopen = this.open.bind(this);
      this.ch.onmessage = this.message.bind(this);
      this.ch.onerror = this.fail.bind(this);
      this.ch.onclose = this.close.bind(this);
    }

    Channel.prototype.open = function() {
      var log_args;
      log_args = ['open'].concat(Array.prototype.slice.call(arguments, 0));
      return this.log.apply(this, log_args);
    };

    Channel.prototype.close = function() {
      var log_args;
      log_args = ['close'].concat(Array.prototype.slice.call(arguments, 0));
      return this.log.apply(this, log_args);
    };

    Channel.prototype.fail = function() {
      var log_args;
      log_args = ['error'].concat(Array.prototype.slice.call(arguments, 0));
      return this.error.apply(this, log_args);
    };

    Channel.prototype.send = function(cmd, data) {
      var message;
      if (data) {
        message = "" + cmd + "|" + data;
      } else {
        message = cmd;
      }
      this.log('Sending', message);
      return this.ch.send(message);
    };

    Channel.prototype.message = function(e) {
      var cmd, data, message, pipe;
      message = e.data;
      this.log('Receiving', message);
      pipe = message.indexOf('|');
      if (pipe > -1) {
        cmd = message.substr(0, pipe);
        data = message.substr(pipe + 1);
      } else {
        cmd = message;
        data = '';
      }
      if (!(cmd in this)) {
        return this.error("Unknown command " + cmd);
      } else {
        return this[cmd](data);
      }
    };

    Channel.prototype.quit = function() {
      return this.ch.close();
    };

    return Channel;

  })(Loggable);

  WebSocket = (function(_super) {
    __extends(WebSocket, _super);

    function WebSocket() {
      _ref = WebSocket.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    WebSocket.prototype.ECHO = function(message) {
      return this.log(message);
    };

    WebSocket.prototype.INIT = function() {
      return this.rtc.user_media();
    };

    WebSocket.prototype.START = function() {
      this.log('Creating offer');
      return this.rtc.peer.offering();
    };

    WebSocket.prototype.CALL = function(message) {
      this.rtc.peer.remote_description(new RTCSessionDescription(JSON.parse(message)));
      return this.rtc.peer.answering();
    };

    WebSocket.prototype.ANSWER = function(message) {
      return this.rtc.peer.remote_description(new RTCSessionDescription(JSON.parse(message)));
    };

    WebSocket.prototype.ICE = function(message) {
      return this.rtc.ice_in(new RTCIceCandidate(JSON.parse(message)));
    };

    WebSocket.prototype.RESET = function() {
      return this.rtc.reset();
    };

    WebSocket.prototype.WAIT = function() {};

    WebSocket.prototype.FULL = function() {
      return alert("There's already 2 persons for this uuid");
    };

    return WebSocket;

  })(Channel);

  Peer = (function(_super) {
    __extends(Peer, _super);

    function Peer(pc, rtc) {
      this.pc = pc;
      this.rtc = rtc;
      this.pc.onicecandidate = this.ice_out.bind(this);
      this.pc.onaddstream = this.stream.bind(this);
      this.pc.ondatachannel = this.data_channel.bind(this);
      this.pc.addStream(this.rtc.local_stream);
    }

    Peer.prototype.ice_in = function(ice) {
      return this.pc.addIceCandidate(ice);
    };

    Peer.prototype.ice_out = function(event) {
      this.log('Got ice', event.candidate);
      if (event.candidate) {
        return this.rtc.ice_out(JSON.stringify(new RTCIceCandidate(event.candidate)));
      }
    };

    Peer.prototype.offering = function() {
      this.log('Offering');
      return this.pc.createOffer(this.caller_local_description.bind(this), this.error.bind(this), {
        mandatory: {
          OfferToReceiveAudio: true,
          OfferToReceiveVideo: true
        }
      });
    };

    Peer.prototype.answering = function() {
      this.log('Answering');
      return this.pc.createAnswer(this.callee_local_description.bind(this), this.error.bind(this), {
        mandatory: {
          OfferToReceiveAudio: true,
          OfferToReceiveVideo: true
        }
      });
    };

    Peer.prototype.caller_local_description = function(desc) {
      this.local_description(desc);
      return this.rtc.calling(JSON.stringify(desc));
    };

    Peer.prototype.callee_local_description = function(desc) {
      this.local_description(desc);
      return this.rtc.answering(JSON.stringify(desc));
    };

    Peer.prototype.local_description = function(desc) {
      this.log('Got local description', desc);
      return this.pc.setLocalDescription(desc);
    };

    Peer.prototype.remote_description = function(desc) {
      this.log('Got remote description', desc);
      return this.pc.setRemoteDescription(desc);
    };

    Peer.prototype.stream = function(event) {
      this.log('Got remote stream', event.stream);
      return this.rtc.assign_remote_stream_url(URL.createObjectURL(event.stream));
    };

    Peer.prototype.data_channel = function(event) {
      this.log('Got remote channel', event.channel);
      return this.remote_channel = new this.rtc.RemoteChannel(event.channel);
    };

    Peer.prototype.make_channel = function() {
      this.log('Got local channel');
      return this.local_channel = new this.rtc.LocalChannel(this.pc.createDataChannel(Math.random.toString()));
    };

    Peer.prototype.quit = function() {
      var _ref1, _ref2;
      if ((_ref1 = this.remote_channel) != null) {
        _ref1.quit();
      }
      if ((_ref2 = this.local_channel) != null) {
        _ref2.quit();
      }
      return this.pc.close();
    };

    return Peer;

  })(Loggable);

  ShoRTCut = (function(_super) {
    __extends(ShoRTCut, _super);

    ShoRTCut.prototype.Peer = Peer;

    ShoRTCut.prototype.Channel = Channel;

    ShoRTCut.prototype.WebSocket = WebSocket;

    function ShoRTCut(options) {
      this.options = options;
      this.Peer = Peer;
      this.LocalChannel = Channel;
      this.RemoteChannel = Channel;
      this.WebSocket = WebSocket;
    }

    ShoRTCut.prototype.start = function() {
      return this.ws = new this.WebSocket(new window.WebSocket('wss://' + document.location.host + '/ws' + location.pathname), this);
    };

    ShoRTCut.prototype.user_media = function() {
      this.log('Getting user media');
      return window.getUserMedia({
        audio: true,
        video: true
      }, this.init.bind(this), this.error.bind(this));
    };

    ShoRTCut.prototype.init = function(stream) {
      this.log('Assigning local stream', stream);
      this.assign_local_stream_url(URL.createObjectURL(stream));
      this.local_stream = stream;
      this.log('Connecting');
      this.connect();
      return this.ws.send('READY');
    };

    ShoRTCut.prototype.calling = function(desc) {
      return this.ws.send('CALL', desc);
    };

    ShoRTCut.prototype.answering = function(desc) {
      return this.ws.send('ANSWER', desc);
    };

    ShoRTCut.prototype.connect = function() {
      this.peer = new this.Peer(new RTCPeerConnection({
        iceServers: [createIceServer('stun:stun.l.google.com:19302'), createIceServer('turn:' + options.turn_server, options.turn_username, options.turn_password)],
        optional: [
          {
            DtlsSrtpKeyAgreement: true
          }
        ]
      }), this);
      return this.peer.make_channel();
    };

    ShoRTCut.prototype.ice_out = function(ice) {
      return this.ws.send('ICE', ice);
    };

    ShoRTCut.prototype.ice_in = function(ice) {
      return this.peer.ice_in(ice);
    };

    ShoRTCut.prototype.reset = function() {
      this.peer.quit();
      return this.connect();
    };

    ShoRTCut.prototype.assign_local_stream_url = function(url) {
      return this.error('You must override this method to set local stream url');
    };

    ShoRTCut.prototype.assign_remote_stream_url = function(url) {
      return this.error('You must override this method to set remote stream url');
    };

    return ShoRTCut;

  })(Loggable);

  this.ShoRTCut = ShoRTCut;

}).call(this);
